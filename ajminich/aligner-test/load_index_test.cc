/**
 * load_index_test.cc
 * Tests the load_index.cc module of SeqAlto aligner-fast.
 *
 * Written by AJ Minich, Jan 2012
 */

#include <cstdlib>
#include <stdio.h>
#include <iostream>
#include <sstream>

#include <gflags/gflags.h>
#include <glog/logging.h>
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include "../src/constants.h"
#include "../src/load_index.h"
#include "testUtils.h"

using namespace std;

// Constants
const string TEST_TARGET = "load_index.cc";

const char* const INDEX_DEFAULT = "/mnt/scratch0/public/data/annotation/hg19/chr21.fa_22.midx";
const int INDEX_ID_DEFAULT = 1337;
const Int64 INDEX_SIZE_DEFAULT = 25769804090;

// Directories
const char* const TMP_DIR_DEFAULT = "";
const char* const MEMORY_DIR = "/dev/shm/";

// Google Flags
DEFINE_string(test_tmp, TMP_DIR_DEFAULT, "tmp directory with sufficient space to store a small alignment.");
DEFINE_string(test_index_file, INDEX_DEFAULT, "Genome index file to load.");
DEFINE_int32(test_index_id, INDEX_ID_DEFAULT, "Index type to use.");
DEFINE_int64(test_index_size, INDEX_SIZE_DEFAULT, "The (correct) size of the index.");

namespace {

    class LoadIndexTest : public ::testing::Test {
      protected:
        
        // Called before the first test in this test case.
        static void SetUpTestCase() {
            
          // Set up names of files saved in shared memory
          memoryFiles.push_back("header");
          memoryFiles.push_back("dicta");
          memoryFiles.push_back("dictb");
          memoryFiles.push_back("genome");
          memoryFiles.push_back("genome_start");
          memoryFiles.push_back("mini");
          
          // Check that tmp directory exists
          bool tmp_directory_exists = ( access( FLAGS_test_tmp.c_str(), 0 ) == 0 );
          ASSERT_TRUE (tmp_directory_exists);
        }
    
        // Called after the last test in this test case.
        static void TearDownTestCase() {
          clearMemory();  
        }
    
        virtual void SetUp() {
          clearMemory();
          
          // Create new SeqAlto params struct
          seqParams = getDefaultSeqParams();
          seqParams->index_id = FLAGS_test_index_id;
        
        }
    
        virtual void TearDown() {
          delete seqParams;
        }
        
        /**
         * Deletes any memory file that may already exist or that may have been
         * generated by the test
         */
        static void clearMemory() {
            for (unsigned int index = 0; index < memoryFiles.size(); index++) {
              remove (getMemoryFileName(index));
            }
        }
        
        // Gets the name of the memory file with the specified index.
        static const char* getMemoryFileName(int index) {
          stringstream ss;
          ss << MEMORY_DIR << memoryFiles[index] << FLAGS_test_index_id;
          return ss.str().c_str();
        }
        
        static vector<string> memoryFiles;
        
        seqalto_params_t * seqParams;
        
    };
    
    vector<string> LoadIndexTest::memoryFiles;
    
    /**
     * Tests that the genome length is correctly measured. Assumes that the index
     * size provided by GFLAGS is the correct size of the specified index file.
     */
    TEST_F(LoadIndexTest, GetGenomeLength) {
        
        // Open hash file and check that it is not null
        gzFile hashFile = gzopen(FLAGS_test_index_file.c_str(), "rb");
        bool hashFileOpened = (hashFile != NULL);
        ASSERT_TRUE(hashFileOpened);        

        uint64_t genomeLength = get_genome_length (hashFile);
        LOG (INFO) << "Genome length measured at " << genomeLength << " bases." << endl;
        
        EXPECT_EQ (FLAGS_test_index_size, genomeLength);
    }
    
    /**
     * Tests that SeqAlto can load a genome index into memory for an individual
     * alignment run. Equivalently, this tests the ability to run seqalto align
     * with the --idx param.
     */
    TEST_F(LoadIndexTest, LoadIndexIntoVars) {
    
      unsigned int options = LOAD_GENOME_FLAG | LOAD_INDEX_FLAG | LOAD_GENOME_START_FLAG |
		LOAD_GENOME_UPPERCASE;
      
      int errorNum = load_index_into_vars(FLAGS_test_index_file, seqParams, options);
      EXPECT_EQ(0, errorNum);
      
      LOG_IF (INFO, errorNum == 0) << "Genome load into memory was successful.";
    }
    
    /**
     * Tests that SeqAlto can load a genome index into shared memory and
     * then access that shared memory. Equivalently, this tests the ability to
     * run seqalto load_index, and then seqalto align without the --idx param.
     */
    TEST_F(LoadIndexTest, SharedMemorySetupAndAccess) {
        
        int errorNum;
        
        gzFile hashFile = gzopen(FLAGS_test_index_file.c_str(), "rb");

        // Check that hash file was successfully opened
        bool cannotOpenHashFile = (hashFile == NULL);
        ASSERT_FALSE(cannotOpenHashFile);

        // Set up the shared memory
        errorNum = setup_shared_memory(hashFile, DEFAULT_MAX_NUM_HASH, FLAGS_test_index_id);
        EXPECT_EQ(0, errorNum);
        
        // Check that all items are in memory
        for (unsigned int index = 0; index < memoryFiles.size(); index++) {
          const char* memoryFile = getMemoryFileName(index);
          bool memoryItemExists = ( access( memoryFile, 0 ) == 0 );
          ASSERT_TRUE (memoryItemExists);
        }
        
        LOG_IF (INFO, errorNum == 0) << "Shared memory setup was successful.";
        
        // Load from shared memory
        errorNum = load_from_shared_memory(seqParams);
        EXPECT_EQ(0, errorNum);
        
        LOG_IF (INFO, errorNum == 0) << "Load from shared memory was successful.";
    }
    
    /**
     * Tests that the main load_index function works correctly.
     */
    /*
    TEST_F(LoadIndexTest, LoadIndexMain) {
        
        // Generate the params
        vector<string> params;
        params.push_back(FLAGS_index_file);
    
        // Call using the same format as main
        
        // Generates too much output currently. Will re-enable actual test
        // when output can be programmatically redirected to files/log
        int error_num = load_index(params);
    
        // Aligner should return an error number of 0 (no error)
        EXPECT_EQ(0, error_num);
    } */

} // namespace

// Runs the tests contained in the LoadIndexTest class.
int main(int argc, char **argv) {
    
    // Initialize logging
    google::InitGoogleLogging (argv [0]);
    google::ParseCommandLineFlags (&argc, &argv, true);
    
    LOG (INFO) << "Starting unit tests on '" << TEST_TARGET << "'.";
    
    // Check that last character of location is a backslash; if not, add it
    if (FLAGS_test_tmp.find_last_of('/') != FLAGS_test_tmp.length() - 1) {
        FLAGS_test_tmp.append("/");
    }
    
    LOG (INFO) << "Using directory '" << FLAGS_test_tmp << "' as temp directory.";
    LOG (INFO) << "Using genome index '" << FLAGS_test_index_file << "' as reference.";
    
    ::testing::InitGoogleTest(&argc, argv);
    
    int result = RUN_ALL_TESTS();
    
    LOG_IF (ERROR, result > 0) << "Unit testing on '" << TEST_TARGET << "' failed.";
    
    return result;
}
